# README for A3
This file describes my solution for implementing an multilevel feedback queue algorithm in C.

## Multilevel Feedback Queue
### Introduction
<p>`mlfq.c` is an implementation of a tick-by-tick simulation of a single-core CPU scheduler for a set of CPU-bound and IO-bound tasks using a multilevel feedback queue. For the solution, no other source code files were added, nor any changes to `queue.c` and `queue.h` were made. This README will mainly focus on functions in `mlfq.c` that were changed from the initial file, and describe the thought process for changing it in this way. This means unchanged functions, such as `main`, will not be talked about since I did not do any work on them. Through this assignment, I was able to get a better understanding of how scheduling works and how to implement such scheduling algorithms.</p>

 ### handle_instruction
 <p>`handle_instruction` processes the input instruction, depending on the type of instruction provided. In this function, there are no task scheduling, pre-emption or task priority changes done; only the processing of tasks. At the start of each iteration of `handle_instruction`, the `task_id` from the instruction is assigned and memory is allocated for the task that is going to be processed. When a new task instruction is read in (burst_time == 0), it will set the `current_queue` to queue_1, since all tasks should start in queue_1, and it will also set the `task_id` to the id provided from the input, which will then be placed in the task_table. When a termination instruction is read in (burst_time == -1), it will be given the task value from the task_table with the current `task_id`. This is then used to get the `waiting_time` stored in `total_waiting_time` and `turn_around_time` stored as `waiting_time + total_execution_time` for the print statement. When CPU burst instruction is read in (burst_time < 0), the task needing CPU bursts is processed. First, it will get the task from the task_table, then set the `burst_time` for the task with the `burst_time` provided from the instruction. The `remaining_burst_time` is also set to the `burst_time` since the `remaining_burst_time` will decrease as CPU bursts are used. This task is then equeued into the queue defined by the tasks `current_queue`.</p>

 ### peek_priority_task
 <p>`peek_priority_task` is used to find the task with the highest priority so that the scheduler will know which task to schedule next. This is simply done by checking if each queue is empty or not, starting with the highest priority queue (queue_1). If it is found that one of the queues is not empty, then it will return the head of the queue, which will be the highest priority task waiting to be scheduled. If all the queues are empty, then it will just return `NULL`.</p>

### scheduler 
<p>The scheduler schedules the next task having the highest priority to be the current task that should be executed. The function starts with findint the highest priority task by using `peek_priority_task`. First it checks if the `current_task` priority needs to be decreased, checking if the task was able to finish in the given quantum. If the task did not finish in the given quantum, it will decrease the priority of the task and enqueue the task to the back of the lower priority queue. Next, it checks if the scheduler needs to pre-empt a task. This is done by checking if `current_task`'s priority is greater than the provided task by `peek_priority_task`. If the new task from `peek_priority_task` has greater priority, it will pre-empt the `current_task` by enqueueing the `current_task` to the back of the `current_queue` and set the new `current_task` as the task provided from `peek_priority_task`. This new `current_task` is dequeued and given quantum to simluate execution. The decreasing of task level and pre-emption is only done if the `current_task` is not empty and they are wrapped in `if` and `else if` statements to tackle an edge case where it would decrease task level and pre-empt in the same interation. This made it so that a task was enqueued one too many times, giving the wrong output. Lastly, it will try and schedule a task normally if there was no pre-emption.</p>

### execute_task
<p>`execute_task` will execute the current task, which is done by updating the `current_task`'s associated times. When the `current_task` is executed, it will decrease the `remaining_burst_time` by one, increase the `total_execution_time` by one and decrease the `remaining_quantum` by one. If the `remaining_burst_time` is exactly zero, it will set the `current_task` to NULL. If there was no `current_task` it will print out `IDLE`.</p>

### update_task_metrics
<p>`update_task_metrics` updates the task metrics of the other tasks waiting in one of the given queues. This is done by looping through the tasks in the task_table and adding one to `total_waiting_time` if it is not the `current_task` and there are still bursts remaining.</p>
